[{"tags":[{"type":"copyright","string":"(c) 2016 able99","html":"<p>(c) 2016 able99</p>"},{"type":"author","string":"able99 (8846755@qq.com)","html":"<p>able99 (8846755@qq.com)</p>"},{"type":"license","string":"MIT","html":"<p>MIT</p>"}],"description":{"full":"<p>bnorth solution</p>","summary":"<p>bnorth solution</p>","body":""},"isPrivate":false,"isConstructor":false,"isClass":false,"isEvent":false,"ignore":false,"line":1,"codeStart":9,"code":"import { ActionState } from '../app/container';\nimport getUuid from '../utils/uuid';\nimport getOptions from '../utils/getOptions';\n\n// actions \n//==================\nconst RequestFetchFetching = 'RequestFetchFetching';\nconst RequestFetchInvalid = 'RequestFetchInvalid';\nconst RequestFetchFetchSuccess = 'RequestFetchFetchSuccess';\nconst RequestFetchFetchFail = 'RequestFetchFetchFail';\nlet requestFetch = (request, options)=>app=>{\n  app.actions.requestFetching(request.uuid);\n  request.trigger('onFetching', true, options.blocking);\n\n  app.network.fetch(options).then(\n    (result)=>{\n      request.trigger('onFetching', false, options.blocking);\n      let ret = request.trigger('onWillChange', result); \n      if(ret)result = ret;\n      if(ret===false) return;\n      app.actions.requestFetchSuccess(request.uuid,result,options.initData,options.append,options.appendField);\n      request.trigger('onDidChange', result);\n    },\n    (error)=>{\n      request.trigger('onFetching', false, options.blocking);\n      app.actions.requestFetchFail(request.uuid,error);\n      request.trigger('onChangeError', error);\n    }\n  ).catch((error)=>{\n    request.trigger('onFetching', false, options.blocking);\n    app.errorNotice(error);\n  });    \n}\nlet requestFetching = (uuid)=>{\n  return {\n    type: RequestFetchFetching,\n    uuid,\n  };\n}\nlet requestFetchInvalid = (uuid)=>{\n  return {\n    type: RequestFetchInvalid,\n    uuid,\n  };\n}\nlet requestFetchSuccess = (uuid,result,initData,append,appendField)=>{\n  return {\n    type: RequestFetchFetchSuccess,\n    uuid,\n    result,\n    initData,\n    append,\n    appendField,\n  };\n}\nlet requestFetchFail = (uuid,error)=>{\n  return {\n    type: RequestFetchFetchFail,\n    uuid,\n    error,\n  };\n}\nlet _requestFetchClear = (uuid)=>(app)=>{\n  let state = app.getState('request',{});\n  delete state.fetchResult[uuid];\n}\n\nlet requestSubmit = (options)=>(app)=>{\n  if(options.blocking!==false)app.actions.noticeBlocking();\n  \n  app.network.operate(options).then(\n    (result)=>{\n      if(options.blocking!==false)app.actions.noticeBlocking(false);\n      if(typeof(options.success)===\"function\"){options.success(result)};\n    },\n    (error)=>{\n      app.error(error);\n      if(options.blocking!==false)app.actions.noticeBlocking(false);\n      if(typeof(options.error)===\"function\"){error = options.error(error)||error};\n      if(error&&options.notice!==false)app.actions.noticeMessage(error, {cTheme: 'alert'});\n    }\n  ).catch((error)=>{\n    app.error(error);\n    if(options.blocking!==false)app.actions.noticeBlocking(false);\n    if(options.notice!==false)app.actions.noticeMessage(error, {cTheme: 'alert'});\n  });  \n}\n\n\n// action state class\n//==================","ctx":false},{"tags":[{"type":"class","string":"","html":""},{"type":"example","string":"**使用**\n// container\ncontainer.states.data = app.actionStates.data({});\ncontainer.states.xxx = app.actionStates.request({\n  resource: 'xxx',\n});\n// page - 使用数据\nthis.props.state_xxx","html":"<p><strong>使用</strong><br />\n// container<br />\ncontainer.states.data = app.actionStates.data({});<br />\ncontainer.states.xxx = app.actionStates.request({<br />\nresource: 'xxx',<br />\n});<br />\n// page - 使用数据<br />\nthis.props.state_xxx</p>"}],"description":{"full":"<p>为app 扩展state 类型，提供网络请求与网络请求数据的管理<br />\n<strong>插件</strong> 该类为插件类扩展了App 的能力<br />\napp.actionStates.request: states 的工厂函数</p>","summary":"<p>为app 扩展state 类型，提供网络请求与网络请求数据的管理<br />\n<strong>插件</strong> 该类为插件类扩展了App 的能力<br />\napp.actionStates.request: states 的工厂函数</p>","body":""},"isPrivate":false,"isConstructor":false,"isClass":true,"isEvent":false,"ignore":false,"line":100,"codeStart":115,"code":"class ActionStateRequest extends ActionState {\n  static stateName = 'request';\n\n  constructor(app, uuid, options){\n    super(app, uuid);\n    this.options = options;\n    this.options.defaultData = this.options.defaultData||{};\n    this.options.initData = this.options.initData || this.options.defaultData;\n    this.options.trackState = Boolean(this.options.trackState);\n    this.options.noticeChangeError = this.options.noticeChangeError !== false;\n  }\n\n  // interface\n  // -------------------------\n  get data() {\n    let state = this.app.getState('request',{});\n    return (state.fetchResult && state.fetchResult[this.uuid] && state.fetchResult[this.uuid].result)||this.options.initData;\n  }\n  get state() { //bnorth use\n    return this.data;\n  }\n  get states() { //bnorth use\n    return {\n      state: this._getState(),\n    };\n  }\n \n  update(aoptions={},append=null){\n    let options = Object.assign( {},\n      getOptions(this.options),\n      getOptions(aoptions),\n      (append===true||append===false)?{append}:{},\n    )\n    if(this.options.onWillUpdate && this.options.onWillUpdate(options)===false) return;\n    this.app.actions.requestFetch(this, options);\n  }\n\n  set(data) {\n    app.actions.requestFetchSuccess(this.uuid,data||{},this.options.initData,this.options.append,this.options.appendField);\n  }\n\n  clear(){\n    this.app.actions._requestFetchClear(this.uuid);\n    delete ActionStateRequest.maps[this.uuid];\n  }\n\n  // state\n  _getState() {\n    let state = this.app.getState('request',{});\n    return (state.fetchResult && state.fetchResult[this.uuid])||{};\n  }\n  getReady(){\n    let state = this._getState();\n    return state.fetching === false && !state.invalid;\n  }\n  getError(){\n    let state = this._getState();\n    return state.error;\n  }\n\n  // event\n  //----------------------------------\n  onStart() { //bnorth use\n    if(!this.options.updateOnStart) return;\n    this.update();\n  }\n\n  onResume() { //bnorth use\n    if(!this.options.updateOnResume) return;\n    this.update();\n  }\n\n  onStop() { //bnorth use\n    if(this.options.clearOnStop===false) return;\n    this.clear();\n  }\n\n  onFetching(show=true, blocking=false) {\n    if(blocking){\n      this.app.actions.noticeBlocking(show);\n    }else{\n      this.app.actions.noticeLoading(show);\n    }\n  }\n\n  onWillChange(result) { \n    return this.options.onWillChange&&this.options.onWillChange(result);\n  }\n\n  onDidChange(result) { \n    return this.options.onDidChange&&this.options.onDidChange(result);\n  }\n\n  onChangeError(error, result){\n    this.app.error(error);\n    if(this.options.onChangeError&&this.options.onChangeError(error, result));\n    this.app.actions.noticeMessage(error, {cTheme: 'alert'});\n  }\n}\n\n\n// reduxer \n//==================\nexport function reduxerRequestFetch( state = {\n  uuid: null,\n  resource: null,\n  fetchResult:{},\n}, action) {\n  switch (action.type) {\n  case RequestFetchFetching:\n    return Object.assign({}, state, {\n      uuid: action.uuid,\n      fetchResult: Object.assign({}, state.fetchResult, {\n        [action.uuid]:Object.assign({}, state.fetchResult[action.uuid], {\n          fetching: true,\n        }),\n      }),\n    });\n  case RequestFetchInvalid:\n    return Object.assign({}, state, {\n      uuid: action.uuid,\n      fetchResult: Object.assign({}, state.fetchResult, {\n        [action.uuid]:Object.assign({}, state.fetchResult[action.uuid], {\n          invalid: true,\n        }),\n      }),\n    });\n  case RequestFetchFetchSuccess:\n    let data = (state.fetchResult[action.uuid]&&state.fetchResult[action.uuid].result)||action.initData;\n    if(action.append&&action.appendField&&data){\n      if(Array.isArray(data)){\n        data = Array.concat(data,action.result);\n      }else{\n        let fileds = Array.isArray(action.appendField)?action.appendField:(typeof(action.appendField)==='string'?[action.appendField]:['data']);\n        for(let field of fileds){\n          action.result[field] = Array.concat(data[field]||[],action.result[field]||[]);\n        }\n        data = Object.assign({},data,action.result);\n      }\n    }else{\n      data = action.result;\n    }\n\n    return Object.assign({}, state, {\n      uuid: action.uuid,\n      fetchResult: Object.assign({}, state.fetchResult, {\n        [action.uuid]:Object.assign({}, state.fetchResult[action.uuid], {\n          invalid: false,\n          fetching: false,\n          result: data,\n        }),\n      }),\n    });\n  case RequestFetchFetchFail:\n    return Object.assign({}, state, {\n      uuid: action.uuid,\n      fetchResult: Object.assign({}, state.fetchResult, {\n        [action.uuid]:Object.assign({}, state.fetchResult[action.uuid], {\n          fetching: false,\n          error: action.error,\n        }),\n      }),\n    });\n\n  default:\n    return state;\n  }\n}\n\n\n// export\n//==================\nexport default {\n  name: 'request',\n  dependence: 'network',\n\n  init(app) {\n    app.actionStates.request = function(options={},uuid=null){\n      return ActionState.instance(ActionStateRequest, app, uuid, options);\n    }\n  },\n  onCreateStoreBefore(app) {\n    Object.assign(app.actions,{\n      requestFetch,\n      requestFetching,\n      requestFetchSuccess,\n      requestFetchFail,\n      requestFetchInvalid,\n      _requestFetchClear,\n      requestSubmit\n    });\n\n    app.reduxers.request = reduxerRequestFetch;\n  },\n}","ctx":{"type":"class","constructor":"ActionStateRequest","cons":"ActionStateRequest","name":"ActionStateRequest","extends":"ActionState","string":"new ActionStateRequest()"}}]